#Tact Switch와 Dot Matrix, Charater Lcd 코드 모두 적용한 엘리베이터 코드

#include <iostream>
#include <set>
#include <wiringPi.h>
#include <thread>
#include <chrono>
#include <lcd.h>

// LCD 설정
const int rs = 11;
const int strb = 10;
const int d0 = 0;
const int d1 = 1;
const int d2 = 2;
const int d3 = 3;

int lcdHandle;

// Dot Matrix에 층수를 표시하는 함수
void displayFloorOnDotMatrix(int floor) {
    int dataPin = 0; // 데이터 핀 번호
    int latchPin = 1; // 래치 핀 번호
    int clockPin = 2; // 클럭 핀 번호

    pinMode(dataPin, OUTPUT);
    pinMode(latchPin, OUTPUT);
    pinMode(clockPin, OUTPUT);

    // 층수에 해당하는 Dot Matrix 패턴 정의
    uint8_t numberPatterns[9][8] = {
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // Placeholder for 0 (if needed)
        {0x00, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18}, // 1
        {0x00, 0x3C, 0x42, 0x02, 0x0C, 0x30, 0x40, 0x7E}, // 2
        {0x00, 0x7E, 0x02, 0x02, 0x1E, 0x02, 0x02, 0x7E}, // 3
        {0x00, 0x0E, 0x12, 0x22, 0x42, 0x7E, 0x02, 0x02}, // 4
        {0x00, 0x7E, 0x40, 0x40, 0x7C, 0x02, 0x02, 0x7C}, // 5
        {0x00, 0x3E, 0x40, 0x40, 0x7E, 0x42, 0x42, 0x3E}, // 6
        {0x00, 0x7E, 0x02, 0x04, 0x08, 0x10, 0x20, 0x20}, // 7
        {0x00, 0x3C, 0x42, 0x42, 0x3C, 0x42, 0x42, 0x3C}, // 8
    };

    uint8_t* pattern = numberPatterns[floor];

    digitalWrite(latchPin, LOW);
    for (int i = 0; i < 8; i++) {
        shiftOut(dataPin, clockPin, MSBFIRST, pattern[i]); // Dot Matrix에 데이터 전송
    }
    digitalWrite(latchPin, HIGH);
}

class Elevator {
public:
    Elevator(int totalFloors) : currentFloor(1), state(STOPPED), totalFloors(totalFloors) {
        wiringPiSetup();
        lcdHandle = lcdInit(2, 16, 4, rs, strb, d0, d1, d2, d3, 0, 0, 0, 0); // LCD 초기화
        for (int i = 0; i < 12; ++i) {
            pinMode(tactSwitchPins[i], INPUT);
            pullUpDnControl(tactSwitchPins[i], PUD_UP); // Tact Switch 초기화
        }
    }

    void callElevator(int floor) {
        if (floor >= 1 && floor <= totalFloors) {
            if (floor == currentFloor) {
                openDoor(); // 현재 층이면 문을 염
            } else {
                targetFloors.insert(floor); // 이동할 층을 추가
                updateState();
            }
        }
    }

    void selectFloor(int floor) {
        if (floor >= 1 && floor <= totalFloors) {
            if (floor == currentFloor) {
                if (targetFloors.find(floor) != targetFloors.end()) {
                    targetFloors.erase(floor); // 이미 선택된 층이면 제거
                    if (targetFloors.empty()) {
                        openDoor(); // 이동할 층이 없으면 문을 염
                    }
                }
            } else {
                targetFloors.insert(floor); // 이동할 층을 추가
                updateState();
            }
        }
    }

    void moveUp() {
        while (!targetFloors.empty() && *targetFloors.begin() > currentFloor) {
            currentFloor++;
            std::this_thread::sleep_for(std::chrono::seconds(1)); // 1초 대기
            displayFloorOnDotMatrix(currentFloor); // Dot Matrix에 현재 층 표시
        }
        if (!targetFloors.empty() && *targetFloors.begin() == currentFloor) {
            targetFloors.erase(targetFloors.begin());
            openDoor(); // 목적 층에 도착하면 문을 염
        }
        updateState();
    }

    void moveDown() {
        while (!targetFloors.empty() && *targetFloors.begin() < currentFloor) {
            currentFloor--;
            std::this_thread::sleep_for(std::chrono::seconds(1)); // 1초 대기
            displayFloorOnDotMatrix(currentFloor); // Dot Matrix에 현재 층 표시
        }
        if (!targetFloors.empty() && *targetFloors.begin() == currentFloor) {
            targetFloors.erase(targetFloors.begin());
            openDoor(); // 목적 층에 도착하면 문을 염
        }
        updateState();
    }

    void updateState() {
        if (targetFloors.empty()) {
            state = STOPPED; // 이동할 층이 없으면 정지 상태
        } else {
            int nextTarget = *targetFloors.begin();
            if (nextTarget > currentFloor) {
                state = MOVING_UP;
                moveUp(); // 위로 이동
            } else if (nextTarget < currentFloor) {
                state = MOVING_DOWN;
                moveDown(); // 아래로 이동
            }
        }
    }

    void openDoor() {
        state = DOOR_OPEN;
        displayStatus("Door Open"); // 상태를 표시
        std::this_thread::sleep_for(std::chrono::seconds(2)); // 2초 대기
        closeDoor();
    }

    void closeDoor() {
        state = DOOR_CLOSED;
        displayStatus("Door Closed"); // 상태를 표시
        std::this_thread::sleep_for(std::chrono::seconds(2)); // 2초 대기
    }

    void displayStatus(const char* status) {
        std::cout << "Status: " << status << std::endl;
        lcdClear(lcdHandle);
        lcdPosition(lcdHandle, 0, 0);
        lcdPuts(lcdHandle, status); // LCD에 상태 메시지 표시
    }

    void run() {
        while (true) {
            int floor = readTactSwitch();
            if (floor != -1) {
                if (floor >= 1 && floor <= 8) {
                    callElevator(floor); // 입력된 층으로 엘리베이터 호출
                } else if (floor == 11) {
                    closeDoor(); // 문 닫기 버튼
                } else {
                    displayStatus("잘못된 입력입니다. 다른 층을 입력해 주세요."); // 잘못된 입력 처리
                    std::this_thread::sleep_for(std::chrono::seconds(2)); // 2초 대기
                    displayStatus(""); // 메시지 지움
                }
            }
            if (state == STOPPED) {
                std::this_thread::sleep_for(std::chrono::seconds(1)); // 1초 대기
            }
        }
    }

private:
    int currentFloor;
    ElevatorState state;
    int totalFloors;
    std::set<int> targetFloors;
    const int tactSwitchPins[12] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11}; // Tact Switch 핀 배열

    int readTactSwitch() {
        for (int i = 0; i < 12; ++i) {
            if (digitalRead(tactSwitchPins[i]) == LOW) {
                if (i <= 7) {
                    return i + 1; // 0-7 핀은 1-8층에 매핑
                } else if (i == 11) {
                    return 11; // 11번 핀은 문 닫기 버튼
                } else {
                    return 0; // 8-10번 핀은 잘못된 입력
                }
            }
        }
        return -1; // 입력 없음
    }
};

int main() {
    Elevator elevator(8); // 8층 엘리베이터 생성
    elevator.run(); // 엘리베이터 실행
    return 0;
}
